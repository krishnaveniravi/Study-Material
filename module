module:
modules ==> libraries

1.inbuilt modules
2.user defined modules

#inbuilt modules: important :math,statistics
import math
import statistics
import os
import sys

using :
help('module') ===>list of modules will display

math, statistics
collections, functools, re, json, os, sys
threading, itertools, date time, 
yaml json csv 

eg:
import statistics
print(dir(statistics)) #-------->list of functions that we can use

   ['Counter', 'Decimal', 'Fraction', 'NormalDist', 'StatisticsError', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', 
  '__loader__', '__name__', '__package__', '__spec__', '_coerce', '_convert', '_exact_ratio', '_fail_neg', '_find_lteq', '_find_rteq', 
  '_isfinite', '_normal_dist_inv_cdf', '_ss', '_sum', 'bisect_left', 'bisect_right', 'erf', 'exp', 'fabs', 'fmean', 'fsum', 'geometric_mean', 
  'groupby', 'harmonic_mean', 'hypot', 'itemgetter', 'log', 'math', 'mean', 'median', 'median_grouped', 
  'median_high', 'median_low', 'mode', 'multimode', 'numbers', 'pstdev', 'pvariance', 'quantiles', 'random', 'sqrt', 'stdev', 'tau', 'variance']

print(statistics.__file__) #------->library path will display
C:\Users\matha\AppData\Local\Programs\Python\Python313\Lib\statistics.py

print(statistics.median([5,6,7,4,3,2,1]))
print(statistics.median([5,6,7,4,3,2,1,8]))

How to use inbuilt module:
#Type1
import math
print(dir(math))
print(math.factorial(5))
print(math.gcd(10,20))
print(math.pi)  

#type2
import math as m  #alias name
print(m.factorial(5))

#Type3
from math import *  #--->calling all functions .eg:without use math.factorial
print(factorial(10))
print(gcd(10,20))

#Type4
from math import cos,factorial #----->calling specific functions
print(cos(180))
print(factorial(10))


#statistiocs :
from statistics import *
import statistics
print(dir(statistics))
print(median([5,6,8,3,9,10]))

USER DEFINED MODULE:
creating a .py file with functions
if we import UDM without adding user defined module in library it will raises an error.
#we can put the user defined modules in library
#then we can use it
eg:
import classexp
print(classexp.func3(10))

import classexp
sys.path.insert(0, '/home/amninder/Desktop/Folder_2') #--->we can insert user defined module in this path
import kamal

#random module:
import random
print(random.choice(range(100000, 999999)))
===========================
#################################################os and sys modules:################################################
https://www.geeksforgeeks.org/python/os-module-python-examples/

os modules:
#Provides functions tointracting with the operating systems.
#OS comes under Python's standard utility modules.
#OS module functions:
   Handling the Current Working Directory
   Creating a Directory
   Listing out Files and Directories with Python
   Deleting Directory or Files using Python
   File Permissions and Metadata
1.1 Getting the Current working directory:
os.getcwd():
import os
cwd=os.getcwd()
print('Current working directory:',cwd)
#output:
Current working directory: C:\Users\matha\PycharmProjects\Test
-----------
1.2 Changing the Current working directory:
os.chdir(path)
   import os
   changedire=os.chdir("../")
   print('Current working directory:',os.getcwd())

#output:
Current working directory: C:\Users\matha\PycharmProjects
--------------------------
2. Creating a Directory
os.mkdir()
os.makedirs()
   2.1 Using os.mkdir():
   #using os.mkdir()
   import os
   directory='module'
   parent_dir = r"C:\Users\matha\PycharmProjects"
   path=os.path.join(parent_dir,directory)
   os.mkdir(path)
   print("Directory '%s' created" % directory)
   
   directory='functions'
   parent_dir = r"C:\Users\matha\PycharmProjects\Test"
   path=os.path.join(parent_dir,directory)
   node=0o666
   os.mkdir(path,node)
   print("Directory '%s' created" % directory)

ouput:
Directory 'module' created
Directory 'functions' created
----------------------------
2.2 Using os.makedirs():
os.makedirs() method is used to create a directory recursively. 
That means while making leaf directory if any intermediate-level directory is missing, os.makedirs() method will create them all.
#using os.makedirs()
   import os
   directory='5am club'
   parent_dir = r"C:\Users\matha\PycharmProjects\books" #---------------->books not exist but using os.makrdirs can create parent directory
   path=os.path.join(parent_dir,directory)
   os.makedirs(path)
   print("Directory '%s' created" % directory)

   directory='Authors'
   parent_dir = r"C:\Users\matha\PycharmProjects"
   path=os.path.join(parent_dir,directory)
   node=0o666
   os.makedirs(path,node)
   print("Directory '%s' created" % directory)
   #output:
   Directory '5am club' created
   Directory 'Authors' created
===============
3. Listing out Files and Directories with Python
os.listdir()
# get the list of all files and directories in the specified directory.
#if we don't give any directory,it will returns the files and directories of current working directory

   import os
   path=r"C:\Users\matha\PycharmProjects"
   dir_list=os.listdir(path)
   print("Files and directions in '",path,"':",dir_list)
   #output:
   Files and directions in ' C:\Users\matha\PycharmProjects ': ['Authors', 'books', 'module', 'osmodules', 'Test']
--------------------
4. Deleting Directory or Files using Python:
Using os.remove() #---->remove or delete a file path.not remove/delete a directory.
                        #If the specified path is a directory then OSError will be raised by the method.
import os
file='file1.txt'
parent=r'C:\Users\matha\PycharmProjects\Authors'
path=os.path.join(parent,file)
os.remove(path)

Using os.rmdir() #--------->To remove or delete an empty directory.If the directory is not empty OSError will be raised

import os
dire='folder1'
parent=r'C:\Users\matha\PycharmProjects'
path=os.path.join(parent,dire)
os.rmdir(path)
==========================
5. File Permissions and Metadata:
Python’s os module provides access to lower-level file system metadata and 
permission handling- useful for scripting, administration and system-level tasks. 

Three important methods in this category are:
#os.chmod(): Change file or directory permissions =========>Permissions must be passed in octal format (e.g., 0o600).
   import os
   #0o600 set for owner to read and write the file
   os.chmod('file2.txt',0o600)
#os.chown(): Change file owner and group (Unix only) --------->It is used in Unix/Linux systems only.

#os.stat(): Fetch metadata like file size, modification time, permissions, etc.
   import os
   
   stats = os.stat("file2.txt")
   
   print("Size:", stats.st_size, "bytes") #size in bytes
   print("Last modified:", stats.st_mtime) #last timestamp
   print("Permissions:", oct(stats.st_mode)[-3:]) #permission last 3 digit
===============
#commonly used functions:
#os.name
import os
print(os.name) #nt

#os.error
#os.popen()
#os.close()
import os
fd = "file2.txt"
file = open(fd, 'r')
text = file.read()
print(text)
os.close(file)

#os.path.exists()==========>True /False 
import os
file=os.path.exists('file2.txt')
print(file) #      True

#os.path.getsize()
import os 
file_size=os.path.getsize('file2.txt')
print(file_size) #48
=====================================================================================
Sys module:
Provides access to variables and functions that interact closely with Python interpreter and runtime environment.
why sys module:
   give access to system specific parameters and functions like command-line arguments.
   Allows interaction with Python runtime environment (e.g., path, version, exit).
   Useful for reading input and writing output using sys.stdin and sys.stdout.
   Enables control over the interpreter with functions like sys.exit() and sys.getsizeof().
   Helps in debugging and managing system-level behavior in Python scripts.

1. sys.version
   import sys
   print(sys.version) 
#prints version of python intrepreter currently in use.
#Helps in identifying compatibility and environment details.
2.sys.platform
print(sys.platform) #win32
-----------
3.sys.exit()
import sys
print("Hello World")
sys.exit()
print("Welcomes you")

#output:
Hello World
-----------
4.sys.stdin:
import sys

for line in sys.stdin:
    if 'q' == line.rstrip():
        break
    print(f'Input : {line}')
print("Exit")
------------- 
5.sys.stdout: Writes output to the standard output stream and allows low-level control over printed output.
   import sys
   sys.stdout.write('hello') #hello
------------
6.sys.stderr:
==========
29/10/25
Collections:
The collections module in Python provides specialized containers 
(different from general purpose built-in containers like dict, list, tuple and set).
Why do we need Collections Module?
   #Provides specialized container data types beyond built-in types like list, dict and tuple.
   #Includes efficient alternatives such as deque, Counter, OrderedDict, defaultdict and namedtuple.
   #Simplifies complex data structure handling with cleaner and faster implementations.
   #Helps in frequency counting, queue operations and structured records with minimal code.
   #Ideal for improving performance and code readability in data-heavy applications.
Counter:
Syntax:
class collections.Counter([iterable-or-mapping])

   from collections import Counter 
   s=['B','B','A','B','C','A','B','B','A','C'] 
   # Creating Counter from a list (sequence of items)  
   print(Counter(s))
     
   # Creating Counter from a dictionary
   print(Counter({'A':3, 'B':5, 'C':2, 'C':2 }))
     
   # Creating Counter using keyword arguments
   print(Counter(A=3, B=5, C=2))
   
   #output:
   Counter({'B': 5, 'A': 3, 'C': 2})
   Counter({'B': 5, 'A': 3, 'C': 2})
   Counter({'B': 5, 'A': 3, 'C': 2})
======================
OrderedDict:

   Syntax:
   class collections.OrderDict()
   
   from collections import OrderedDict 
   print("This is a Dict:\n") 
   d = {} 
   d['a'] = 1
   d['b'] = 2
   d['c'] = 3
   d['d'] = 4  
   for key, value in d.items(): 
       print(key, value) 
     
   print("\nThis is an Ordered Dict:\n") 
   od = OrderedDict() 
   od['a'] = 1
   od['b'] = 2
   od['c'] = 3
   od['d'] = 4  
   for key, value in od.items(): 
       print(key, value)
==============
   Example (Deleting and reinserting a key):
   from collections import OrderedDict 
   od = OrderedDict() 
   od['a'] = 1
   od['b'] = 2
   od['c'] = 3
   od['d'] = 4
     
   print('Before Deleting')
   for key, value in od.items(): 
       print(key, value)     
   # deleting element
   od.pop('a')
   # Re-inserting the same
   od['a'] = 1​
   print('\nAfter re-inserting')
   for key, value in od.items(): 
       print(key, value)
   
   #output:
   Before Deleting
   a 1
   b 2
   c 3
   d 4
   
   After re-inserting
   b 2
   c 3
   d 4
   a 1
=======================
DefaultDict:
   DefaultDict is a sub class of dictionary.
   It is used to provide some default values for the key that does not exist and never raises a KeyError.  
   
   Syntax:
   class collections.defaultdict(default_factory)
   
   DefaultDict objects can be initialized using DefaultDict() method 
   by passing the data type as an argument.
   
   from collections import defaultdict
   res=defaultdict(int)     ## Creating a defaultdict with default value of 0 (int)
   L = [1, 2, 3, 4, 2, 4, 1, 2] 
   # Counting occurrences of each element in the list
   for i in l:
      res[i]+=1 # No need to check key existence; default is 0
   print(res)  #defaultdict(<class 'int'>, {1: 2, 2: 3, 3: 1, 4: 2})
   -------------
   Dictionary with values as list:
   
   from collections import defaultdict
   res=defaultdict(list)
   for i in range(5):
      d[i].append(i)
      #d[i]=[i]
   print(res)
===========
ChainMap:
   A ChainMap encapsulates many dictionaries into a single unit and returns a list of dictionaries.
   
   Syntax:
   class collections.ChainMap(dict1, dict2)
   
   from collections import ChainMap
   d1 = {'a': 1, 'b': 2}
   d2 = {'c': 3, 'd': 4}
   d3 = {'e': 5, 'f': 6}
   c=ChainMap(d1,d2,d3)
   print(c)
   #ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'e': 5, 'f': 6})
---------
   Accessing Keys and Values from ChainMap:
   from collections import ChainMap 
   d1 = {'a': 1, 'b': 2}
   d2 = {'c': 3, 'd': 4}
   d3 = {'e': 5, 'f': 6}
   # Defining the chainmap 
   c = ChainMap(d1, d2, d3)   
   # Accessing Values using key name
   print(c['a'])
   # Accessing values using values()
   print(c.values())
   # Accessing keys using keys()
   print(c.keys())
   #output
   1
   ValuesView(ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'e': 5, 'f': 6}))
   KeysView(ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'e': 5, 'f': 6}))
--------------
Adding new dictionary:
   new_child()
   
   d4={'g':8}
   res=c.new_child(d4)
   print(res)
==================
NamedTuple:
   A NamedTuple is like a regular tuple but with named fields, making data more readable and accessible.
   Instead of using indexes, you can access elements by name.
   
   Syntax:
   class collections.namedtuple(typename, field_names)

from collections import namedtuple
#initializing the namedtuple
student=namedtuple('student',['name','age','DOB'])

#ASSIGN THE VALUE 
s=student('mathan','20','19081997')

#accessing the age by index
print('student age:',s[1])

#accessing the name by namedtuple
print('student age:',s.name)
----------
1. _make(): This function is used to return a namedtuple() from the iterable passed as argument.
2. _asdict(): This function returns the OrdereDict() as constructed from the mapped values of namedtuple().

   from collections import namedtuple
   from collections import namedtuple
   #initializing the namedtuple
   student=namedtuple('student',['name','age','DOB'])
   
   #ASSIGN THE VALUE 
   s=student('mathan','20','19081997')
   
   #initializing the iterable
   li=['krish','21','16071998']
   
   #initialize the dictionary
   di = { 'name' : "Nikhil", 'age' : 19 , 'DOB' : '1391997' } 
   
   # using _make() to return namedtuple() 
   print (Student._make(li)) 
     
   # using _asdict() to return an OrderedDict() 
   print (S._asdict())
   
   #output
   Student(name='Manjeet', age='19', DOB='411997')
   {'name': 'Nandini', 'age': '19', 'DOB': '2541997'}

==============
Deque:
Deque (Doubly Ended Queue) is the optimized list for quicker append and pop operations from both sides of the container. 
Syntax:
class collections.deque(list)

from collections import deque
  
# Declaring deque
   queue = deque(['name','age','DOB']) 
   print(queue) #deque(['name', 'age', 'DOB'])
   Inserting Elements:
   queue =deque([1, 2, 3]) 
   de.append(4) ## Append 4 to the right end of deque
   de.appendleft(6) # Append 6 to the left end of deque
   print(queue) #deque([6, 1, 2, 3, 4])
#Removing Elements:
de = deque([6, 1, 2, 3, 4])
# Delete element from the right end (removes 4)
de.pop()
# Delete element from the left end (removes 6)
de.popleft()
print(de) #deque([1, 2, 3])
===========
UserDict
UserList
UserString
===============================================================================================================================================================
4/11/25
time module:

The time module in Python provides functions for handling time-related tasks.

The time-related tasks includes,
  1. reading the current time
  2. formatting time
  3. sleeping for a specified number of seconds and so on.

Python time.time() Function:
   In Python, the time() function returns the number of seconds passed since epoch (the point where time begins).
   For the Unix system, January 1, 1970, 00:00:00 at UTC is epoch.
  

# import the time module
import time
# get the current time in seconds since the epoch
seconds = time.time()
print("Seconds since epoch =", seconds)	
=================
Python time.ctime() Function:
   The time.ctime() function in Python takes seconds passed since epoch as an argument 
   and returns a string representing local time.
   
   import time
   seconds = 1772215379.5045543
   local_time = time.ctime(seconds)
   print("Local time:", local_time)
====================
Python time.sleep() Function:
The sleep() function suspends (delays) execution of the current thread for the given number of seconds.

import time

print("Printed immediately.")
time.sleep(2.4)
print("Printed after 2.4 seconds.")
==================
Python time.localtime() Function:

The localtime() function takes the number of seconds passed since epoch as an argument 
and returns struct_time (a tuple containing 9 elements corresponding to struct_time) in local time.
import time
result = time.localtime(1672214933)
print("result:", result)
print("\nyear:", result.tm_year)
print("tm_hour:", result.tm_hour)

result: time.struct_time(tm_year=2022, tm_mon=12, tm_mday=28, tm_hour=8, tm_min=8, tm_sec=53, tm_wday=2, tm_yday=362, tm_isdst=0)

year: 2022
tm_hour: 8
=====================
Python time.gmtime() Function
struct_time in UTC
=============
Python time.mktime() Function:
The mktime() function takes struct_time (a tuple containing 9 elements corresponding to struct_time) 
as an argument and returns the seconds passed since epoch in local time.

The struct_time has the following structure:
(year, month, day, hour, minute, second, weekday, day of the year, daylight saving)
=========
Python time.asctime() Function:

similar to time.mktime()
time.asctime() converts the time tuple to a human-readable string.

import time

t = (2022, 12, 28, 8, 44, 4, 4, 362, 0)

result = time.asctime(t)
print("Result:", result)

# Output: Result: Fri Dec 28 08:44:04 2022
======================
Python time.strftime() Function:

import time

named_tuple = time.localtime() # get struct_time
time_string = time.strftime("%m/%d/%Y, %H:%M:%S", named_tuple)

print(time_string)
==============
Python time.strptime() Function:

import time

time_string = "14 July, 2023"
result = time.strptime(time_string, "%d %B, %Y")

print(result)












